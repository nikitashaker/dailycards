// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cards.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCard = `-- name: CreateCard :one
INSERT INTO cards (question, answer, pack_id, rating)
VALUES ($1, $2, $3, $4)
RETURNING id, question, answer, pack_id, rating, created_at, updated_at, last_wrong
`

type CreateCardParams struct {
	Question string
	Answer   string
	PackID   pgtype.UUID
	Rating   pgtype.Int4
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (Card, error) {
	row := q.db.QueryRow(ctx, createCard,
		arg.Question,
		arg.Answer,
		arg.PackID,
		arg.Rating,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.Answer,
		&i.PackID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastWrong,
	)
	return i, err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE FROM cards WHERE id = $1
`

func (q *Queries) DeleteCard(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCard, id)
	return err
}

const listCardsByPack = `-- name: ListCardsByPack :many
SELECT id, question, answer, pack_id, rating, created_at, updated_at, last_wrong
FROM cards
WHERE pack_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCardsByPack(ctx context.Context, packID pgtype.UUID) ([]Card, error) {
	rows, err := q.db.Query(ctx, listCardsByPack, packID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.Question,
			&i.Answer,
			&i.PackID,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastWrong,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepeatCards = `-- name: ListRepeatCards :many
SELECT id, question, answer, pack_id, rating, created_at, updated_at, last_wrong FROM cards
WHERE pack_id = $1
ORDER BY last_wrong DESC, created_at ASC
`

func (q *Queries) ListRepeatCards(ctx context.Context, packID pgtype.UUID) ([]Card, error) {
	rows, err := q.db.Query(ctx, listRepeatCards, packID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.Question,
			&i.Answer,
			&i.PackID,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastWrong,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCardWrong = `-- name: MarkCardWrong :exec
UPDATE cards
SET last_wrong = $1
WHERE id = $2
`

type MarkCardWrongParams struct {
	LastWrong pgtype.Bool
	ID        pgtype.UUID
}

func (q *Queries) MarkCardWrong(ctx context.Context, arg MarkCardWrongParams) error {
	_, err := q.db.Exec(ctx, markCardWrong, arg.LastWrong, arg.ID)
	return err
}

const readCard = `-- name: ReadCard :one
SELECT id, question, answer, pack_id, rating, created_at, updated_at, last_wrong FROM cards WHERE id = $1
`

func (q *Queries) ReadCard(ctx context.Context, id pgtype.UUID) (Card, error) {
	row := q.db.QueryRow(ctx, readCard, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.Answer,
		&i.PackID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastWrong,
	)
	return i, err
}

const updateCard = `-- name: UpdateCard :one
UPDATE cards
SET question = $1, answer = $2, rating = 2
WHERE id = $3
RETURNING id, question, answer, pack_id, rating, created_at, updated_at, last_wrong
`

type UpdateCardParams struct {
	Question string
	Answer   string
	ID       pgtype.UUID
}

func (q *Queries) UpdateCard(ctx context.Context, arg UpdateCardParams) (Card, error) {
	row := q.db.QueryRow(ctx, updateCard, arg.Question, arg.Answer, arg.ID)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.Answer,
		&i.PackID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastWrong,
	)
	return i, err
}
