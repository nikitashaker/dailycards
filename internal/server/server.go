package server

import (
	"errors"
	"net/http"

	"github.com/gorilla/sessions"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	echoSession "github.com/labstack/echo-contrib/session"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"golang.org/x/crypto/bcrypt"

	db "dailycards/internal/database"
)

type Server struct {
	srv    *echo.Echo
	db     *db.Queries
	secret string
}

func New(q *db.Queries, secret string) *Server {
	return &Server{srv: echo.New(), db: q, secret: secret}
}

func (s *Server) Setup() {
	store := sessions.NewCookieStore([]byte(s.secret))
	store.Options = &sessions.Options{
		Path:     "/",
		HttpOnly: true,
		MaxAge:   86400,
		SameSite: http.SameSiteLaxMode, // –∏—Å–ø–æ–ª—å–∑—É–µ–º Lax
		Secure:   false,                // **–≤–∞–∂–Ω–æ** –Ω–∞ HTTP
	}
	s.srv.Use(echoSession.Middleware(store))
	
	s.srv.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins:     []string{"http://localhost:8080"},
		AllowMethods:     []string{echo.GET, echo.POST, echo.DELETE},
		AllowHeaders:     []string{echo.HeaderContentType},
		AllowCredentials: true,
	}))

	s.srv.Use(middleware.Logger(), middleware.Recover())

	s.srv.Use(middleware.StaticWithConfig(middleware.StaticConfig{
		HTML5:      true,
		Root:       "web",
	}))

	api := s.srv.Group("/api")
	api.POST("/users", s.CreateUser)
	api.POST("/login", s.HandleLogin)
	api.POST("/logout", s.HandleLogout)
	api.GET("/me", s.HandleMe)

	auth := api.Group("")
	auth.Use(s.SessionAuth)
	auth.POST("/packs", s.CreatePack)
	auth.GET("/packs", s.ListPacks)
	auth.DELETE("/packs/:id", s.DeletePack)
	auth.POST("/packs/:pack_id/cards", s.CreateCard)
	auth.GET("/packs/:pack_id/cards", s.ListCards)
	auth.GET( "/packs/:pack_id/repeat", s.RepeatPack)
	auth.POST("/packs/:pack_id/finish", s.FinishPack)
	auth.GET( "/stats",               s.UserStats)
}

// Serve –∑–∞–ø—É—Å–∫–∞–µ—Ç HTTP‚Äë—Å–µ—Ä–≤–µ—Ä –Ω–∞ :8080
func (s *Server) Serve() error {
	s.srv.Debug = true
	return s.srv.Start(":8080")
}

/* ------------------  USERS  ------------------ */

type CreateUserRequest struct {
	Username string `json:"username" form:"username"`
	Password string `json:"password" form:"password"`
}

func (s *Server) CreateUser(c echo.Context) error {
	var req CreateUserRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "failed to read data: " + err.Error(),
		})
	}
	if req.Username == "" || req.Password == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "username and password must not be empty",
		})
	}
	hashed, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "hashing error: " + err.Error(),
		})
	}

	params := db.CreateUserParams{
		Username:     req.Username,
		PasswordHash: string(hashed),
	}

	_, err = s.db.CreateUser(c.Request().Context(), params)
	if err != nil {
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) && pgErr.Code == "23505" {
			return c.JSON(http.StatusConflict, map[string]string{
				"error": "user with this username already exists",
			})
		}
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "db error: " + err.Error(),
		})
	}

	return c.JSON(http.StatusCreated, map[string]string{
		"message": "user successfully created",
	})
}

/* ------------------  PACKS  ------------------ */

type CreatePackRequest struct {
	Name     string `json:"name"`
	Category string `json:"category"`
}

func (s *Server) CreatePack(c echo.Context) error {
	var req CreatePackRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "failed to read data: " + err.Error(),
		})
	}
	if req.Name == "" || req.Category == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "name and category must not be empty",
		})
	}

	params := db.CreatePackParams{
		Name:     req.Name,
		Category: pgtype.Text{String: req.Category, Valid: true},
	}

	pack, err := s.db.CreatePack(c.Request().Context(), params)
	if err != nil {
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) && pgErr.Code == "23505" {
			return c.JSON(http.StatusConflict, map[string]string{
				"error": "pack with this name already exists",
			})
		}
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "db error: " + err.Error(),
		})
	}

	return c.JSON(http.StatusCreated, map[string]string{
		"message":  "pack successfully created",
		"id":       pack.ID.String(),
		"category": pack.Category.String,
	})
}

// ListPacks –æ—Ç–¥–∞—ë—Ç –≤—Å–µ –ø–∞–∫–∏ –∏–∑ –ë–î
func (s *Server) ListPacks(c echo.Context) error {
    // (–µ—Å–ª–∏ –Ω—É–∂–Ω—ã —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –ø–∞–∫–∏) –º–æ–∂–Ω–æ –∑–¥–µ—Å—å –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å user_id –∏–∑ —Å–µ—Å—Å–∏–∏
    packs, err := s.db.ListPacks(c.Request().Context())
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{"error": "db error: " + err.Error()})
    }
    return c.JSON(http.StatusOK, packs)
}


func (s *Server) DeletePack(c echo.Context) error {
	idParam := c.Param("id")
	var packID pgtype.UUID
	if err := packID.Scan([]byte(idParam)); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "invalid pack id",
		})
	}

	if err := s.db.DeletePack(c.Request().Context(), packID); err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "db error: " + err.Error(),
		})
	}
	return c.NoContent(http.StatusNoContent)
}

/* ------------------  CARDS  ------------------ */

type CreateCardRequest struct {
	Question string `json:"question"`
	Answer   string `json:"answer"`
	Rating   *int32 `json:"rating,omitempty"`
}

func (s *Server) CreateCard(c echo.Context) error {
	packIDStr := c.Param("pack_id")
	var packID pgtype.UUID

	if err := packID.Scan(packIDStr); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid pack_id"})
	}

	var req CreateCardRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "cannot parse body: " + err.Error(),
		})
	}
	if req.Question == "" || req.Answer == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "question and answer are required",
		})
	}

	rating := pgtype.Int4{Int32: 0, Valid: true}
	if req.Rating != nil {
		rating = pgtype.Int4{Int32: *req.Rating, Valid: true}
	}

	card, err := s.db.CreateCard(c.Request().Context(), db.CreateCardParams{
		Question: req.Question,
		Answer:   req.Answer,
		PackID:   packID,
		Rating:   rating,
	})
	if err != nil {
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) && pgErr.Code == "23503" {
			return c.JSON(http.StatusNotFound, map[string]string{"error": "pack not found"})
		}
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusCreated, card)
}


func (s *Server) ListCards(c echo.Context) error {
	packIDParam := c.Param("pack_id")
	var packID pgtype.UUID

	if err := packID.Scan(packIDParam); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "invalid pack_id",
		})
	}

	cards, err := s.db.ListCardsByPack(c.Request().Context(), packID)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "db error: " + err.Error(),
		})
	}

	// üßº –ß–∏—Å—Ç—ã–π –º–∞—Å—Å–∏–≤ –∫–∞—Ä—Ç –¥–ª—è —Ñ—Ä–æ–Ω—Ç–∞
	result := make([]map[string]interface{}, 0, len(cards))
	for _, card := range cards {
		result = append(result, map[string]interface{}{
			"id":       card.ID.String(),
			"question": card.Question,
			"answer":   card.Answer,
			"rating":   card.Rating.Int32, // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º pgtype.Int4 –≤ –æ–±—ã—á–Ω–æ–µ —á–∏—Å–ª–æ
		})
	}

	return c.JSON(http.StatusOK, result)
}



/* ------------------  AUTH  ------------------ */

func (s *Server) HandleLogin(c echo.Context) error {
	var req struct {
		Username string `json:"username"`
		Password string `json:"password"`
	}
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid request"})
	}

	user, err := s.db.GetUserByUsername(c.Request().Context(), req.Username)
	if err != nil || bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)) != nil {
		return c.JSON(http.StatusUnauthorized, map[string]string{"error": "invalid credentials"})
	}

	sess, _ := echoSession.Get("session", c)
	sess.Values["user_id"] = user.ID.String()

	// ‚òÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ—Å—Å–∏—é –∏ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, —á—Ç–æ–±—ã –Ω–µ —É–ø–∞–ª–æ –Ω–∞ 500
	if err := sess.Save(c.Request(), c.Response().Writer); err != nil {
		c.Logger().Warn("session save failed:", err)
	}

	return c.JSON(http.StatusOK, map[string]string{"message": "logged in"})
}

func (s *Server) SessionAuth(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		sess, _ := echoSession.Get("session", c)
		if id, ok := sess.Values["user_id"].(string); !ok || id == "" {
			return c.JSON(http.StatusUnauthorized, map[string]string{"error": "unauthorized"})
		}
		return next(c)
	}
}

func (s *Server) HandleMe(c echo.Context) error {
	sess, _ := echoSession.Get("session", c)
	idRaw, ok := sess.Values["user_id"].(string)
	if !ok || idRaw == "" {
		return c.JSON(http.StatusUnauthorized, map[string]string{"error": "unauthorized"})
	}

	var uid pgtype.UUID
	if err := uid.Scan(idRaw); err != nil {
		return c.JSON(http.StatusUnauthorized, map[string]string{"error": "invalid session"})
	}

	user, err := s.db.GetUserByID(c.Request().Context(), uid)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "db error"})
	}
	return c.JSON(http.StatusOK, map[string]string{"username": user.Username})
}

func (s *Server) HandleLogout(c echo.Context) error {
	sess, _ := echoSession.Get("session", c)
	sess.Options.MaxAge = -1

	// ‚òÖ —Ç–æ–∂–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º, —á—Ç–æ–±—ã –±—Ä–∞—É–∑–µ—Ä —É–±—Ä–∞–ª –∫—É–∫–∏
	_ = sess.Save(c.Request(), c.Response().Writer)
	return c.NoContent(http.StatusNoContent)
}

// ======================
// –ò–Ω—Ç–µ—Ä–≤–∞–ª—å–Ω–æ–µ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ
// ======================

// RepeatPack –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ –Ω—É–∂–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
func (s *Server) RepeatPack(c echo.Context) error {
    var pid pgtype.UUID
    if err := pid.Scan(c.Param("pack_id")); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid pack_id"})
    }

    rows, err := s.db.ListRepeatCards(c.Request().Context(), pid)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{"error": "db error: " + err.Error()})
    }

    // ‚Üê –∑–¥–µ—Å—å –≤–º–µ—Å—Ç–æ return c.JSON(‚Ä¶, rows) –¥–µ–ª–∞–µ–º —è–≤–Ω–æ–µ –º–∞–ø–ø–∏–Ω–≥:
    out := make([]map[string]interface{}, 0, len(rows))
    for _, card := range rows {
        out = append(out, map[string]interface{}{
            "id":         card.ID.String(),
            "question":   card.Question,
            "answer":     card.Answer,
            "rating":     card.Rating.Int32,  // Int4 ‚Üí int
            "last_wrong": card.LastWrong.Bool, // Bool ‚Üí bool
        })
    }

    return c.JSON(http.StatusOK, out)
}

// FinishPack –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–µ—Å—Å–∏–∏ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è
func (s *Server) FinishPack(c echo.Context) error {
    // 1) –±–µ—Ä—ë–º user_id –∏–∑ —Å–µ—Å—Å–∏–∏
    sess, _ := echoSession.Get("session", c)
    uidStr, ok := sess.Values["user_id"].(string)
    if !ok || uidStr == "" {
        return c.JSON(http.StatusUnauthorized, map[string]string{"error":"unauthorized"})
    }

    // 2) —á–∏—Ç–∞–µ–º —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞
    var body struct {
        Stats []struct {
            CardID  string `json:"card_id"`
            Correct bool   `json:"correct"`
        } `json:"stats"`
    }
    if err := c.Bind(&body); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{"error":"invalid body"})
    }

    // 3) –æ–±–Ω–æ–≤–ª—è–µ–º last_wrong, —Å—á–∏—Ç–∞–µ–º –¥–µ–ª—å—Ç—É —Ä–µ–π—Ç–∏–Ω–≥–∞
    delta := 0
    allCorrect := true
    for _, st := range body.Stats {
        // –æ—Ç–º–µ—Ç–∫–∞ –æ —Ç–æ–º, —á—Ç–æ –≤ –ø—Ä–æ—à–ª—ã–π —Ä–∞–∑ –±—ã–ª–∞ –æ—à–∏–±–∫–∞
        _ = s.db.MarkCardWrong(c.Request().Context(), db.MarkCardWrongParams{
            LastWrong: pgtype.Bool{Bool: !st.Correct, Valid: true},
            ID:        uuidFromString(st.CardID),
        })

        if st.Correct {
            delta++
        } else {
            delta--
            allCorrect = false
        }
    }

    // 4) –æ–±–Ω–æ–≤–ª—è–µ–º –æ–±—â–∏–π —Ä–µ–π—Ç–∏–Ω–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    _ = s.db.AddUserRating(c.Request().Context(), db.AddUserRatingParams{
        Rating: pgtype.Int4{Int32: int32(delta), Valid: true},
        UserID: uuidFromString(uidStr),
    })

    // 5) –µ—Å–ª–∏ –Ω–∏ —Ä–∞–∑—É –Ω–µ –æ—à–∏–±–∏–ª—Å—è ‚Äî +1 –∫ mastered
    if allCorrect {
        _ = s.db.IncPacksMastered(c.Request().Context(), uuidFromString(uidStr))
    }

    return c.NoContent(http.StatusNoContent)
}

// UserStats –æ—Ç–¥–∞—ë—Ç –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
func (s *Server) UserStats(c echo.Context) error {
    sess, _ := echoSession.Get("session", c)
    uidStr, ok := sess.Values["user_id"].(string)
    if !ok || uidStr == "" {
        return c.JSON(http.StatusUnauthorized, map[string]string{"error":"unauthorized"})
    }

    stats, err := s.db.GetUserStats(c.Request().Context(), uuidFromString(uidStr))
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{"error":"db error: "+err.Error()})
    }
    return c.JSON(http.StatusOK, stats)
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫–∏ –≤ pgtype.UUID
func uuidFromString(s string) pgtype.UUID {
    var u pgtype.UUID
    _ = u.Scan(s) // –æ—à–∏–±–∫—É –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º, –ø—Ä–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–º id –ø—Ä–∏–¥—ë—Ç 400 –Ω–∞ Scan –≤—ã—à–µ
    return u
}
